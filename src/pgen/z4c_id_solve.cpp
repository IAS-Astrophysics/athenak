//========================================================================================
// AthenaK: astrophysical fluid dynamics & numerical relativity code
// Copyright(C) 2020 James M. Stone <jmstone@ias.edu> and the Athena code team
// Licensed under the 3-clause BSD License (the "LICENSE")
//========================================================================================
//! \file z4c_id_solve.cpp
//  \brief Problem generator for loading in initial data generated by
//  id_solve

#include <algorithm>
#include <array>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <Kokkos_Timer.hpp>

#include "athena.hpp"
#include "coordinates/cell_locations.hpp"
#include "coordinates/adm.hpp"
#include "globals.hpp"
#include "mesh/mesh.hpp"
#include "parameter_input.hpp"
#include "z4c/z4c.hpp"
#include "z4c/z4c_amr.hpp"

#include <hdf5.h>

//-----------------------------------------------------------------------------
// Read a full dataset of doubles from an HDF5 file.
void read_hdf5(const char *filename, double **data, hsize_t *dims, char *DATASET_NAME) {
    hid_t  file_id, dataset_id, dataspace_id;
    herr_t status;

    // Open the HDF5 file
    file_id = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_id < 0) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return;
    }

    // Open the dataset
    dataset_id = H5Dopen2(file_id, DATASET_NAME, H5P_DEFAULT);
    if (dataset_id < 0) {
        std::cerr << "Error opening dataset: " << DATASET_NAME << std::endl;
        H5Fclose(file_id);
        return;
    }

    // Get dataspace and dimensions
    dataspace_id = H5Dget_space(dataset_id);
    H5Sget_simple_extent_dims(dataspace_id, dims, NULL);

    // Compute total size
    int rank = H5Sget_simple_extent_ndims(dataspace_id);
    int total_size = 1;
    for (int d = 0; d < rank; ++d) total_size *= dims[d];

    // Allocate and read
    *data = (double*)std::malloc(total_size * sizeof(double));
    if (*data == nullptr) {
        std::cerr << "Memory allocation failed for dataset " << DATASET_NAME << std::endl;
        H5Sclose(dataspace_id);
        H5Dclose(dataset_id);
        H5Fclose(file_id);
        return;
    }
    status = H5Dread(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, *data);
    if (status < 0) {
        std::cerr << "Error reading dataset " << DATASET_NAME << std::endl;
    }

    // Cleanup
    H5Sclose(dataspace_id);
    H5Dclose(dataset_id);
    H5Fclose(file_id);
}

//-----------------------------------------------------------------------------
// Find the index in A[inds..inde) whose value is closest to B.
int find_closest_index(double *A, int inds, int inde, double B) {
    int index = inds;
    double min_diff = std::fabs(A[inds] - B);
    for (int i = inds + 1; i < inde; ++i) {
        double diff = std::fabs(A[i] - B);
        if (diff < min_diff) {
            min_diff = diff;
            index = i;
        }
    }
    return index - inds;
}

// Forward declarations
void LoadIDSolveData(MeshBlockPack *pmbp, const std::string &file_name);
void RefinementCondition(MeshBlockPack *pmbp);

//----------------------------------------------------------------------------------------
//! \fn ProblemGenerator::UserProblem_()
//! \brief Problem Generator for id_solve initial data
void ProblemGenerator::UserProblem(ParameterInput *pin, const bool restart) {
    user_ref_func = RefinementCondition;
    if (restart) return;

    MeshBlockPack *pmbp = pmy_mesh_->pmb_pack;
    auto &indcs = pmy_mesh_->mb_indcs;

    std::cout << pin->GetOrAddString("problem", "id_filename", "EMPTY") << std::endl;

    std::cout << "Start Loading id_solve Initial Data" << std::endl;
    LoadIDSolveData(
        pmbp,
        pin->GetOrAddString("problem", "id_filename", "EMPTY"));

    // Set lapse from conformal factor
    pmbp->pz4c->GaugePreCollapsedLapse(pmbp, pin);

    // Set Z4c variables from ADM variables
    switch (indcs.ng) {
      case 2: pmbp->pz4c->ADMToZ4c<2>(pmbp, pin); break;
      case 3: pmbp->pz4c->ADMToZ4c<3>(pmbp, pin); break;
      case 4: pmbp->pz4c->ADMToZ4c<4>(pmbp, pin); break;
    }

    // Compute ADM constraints on initial slice
    switch (indcs.ng) {
      case 2: pmbp->pz4c->ADMConstraints<2>(pmbp); break;
      case 3: pmbp->pz4c->ADMConstraints<3>(pmbp); break;
      case 4: pmbp->pz4c->ADMConstraints<4>(pmbp); break;
    }

    std::cout << "Loading initial data complete." << std::endl;
}
//-----------------------------------------------------------------------------
//! \brief Load id_solve initial data from HDF5 into AthenaK mesh
void LoadIDSolveData(MeshBlockPack *pmbp, const std::string &file_name) {
  // 1) Read coordinate arrays
  double *data_x1v=nullptr, *data_x2v=nullptr, *data_x3v=nullptr;
  hsize_t dims_x[2], dims_y[2], dims_z[2];
  read_hdf5(file_name.c_str(), &data_x1v, dims_x, const_cast<char*>("x1v"));
  read_hdf5(file_name.c_str(), &data_x2v, dims_y, const_cast<char*>("x2v"));
  read_hdf5(file_name.c_str(), &data_x3v, dims_z, const_cast<char*>("x3v"));

  int number_of_meshblocks =        static_cast<int>(dims_x[0]);
  int meshblock_dimx     =        static_cast<int>(dims_x[1]);
  int meshblock_dimy     =        static_cast<int>(dims_y[1]);
  int meshblock_dimz     =        static_cast<int>(dims_z[1]);

  // 2) Read the metric (6 comps) and extrinsic (6 comps) datasets
  double *metric_data=nullptr, *extrin_data=nullptr;
  hsize_t dims_m[5], dims_e[5];
  read_hdf5(file_name.c_str(), &metric_data, dims_m, const_cast<char*>("metric"));
  read_hdf5(file_name.c_str(), &extrin_data, dims_e, const_cast<char*>("extrin"));

  // dims_m = {6, #blocks, NX, NY, NZ}
  int ncomp       = static_cast<int>(dims_m[0]);  // should be 6
  int nblocks     = static_cast<int>(dims_m[1]);  // should match number_of_meshblocks
  int NX          = static_cast<int>(dims_m[2]);
  int NY          = static_cast<int>(dims_m[3]);
  int NZ          = static_cast<int>(dims_m[4]);
  int block_vol   = NX*NY*NZ;
  int comp_stride = nblocks * block_vol;         // bytes between successive components

  // 3) Prepare AthenaK ADM host views
  auto &u_adm      = pmbp->padm->u_adm;
  auto  host_u_adm = create_mirror(u_adm);
  z4c::Z4c::ADMhost_vars host_adm;
  host_adm.psi4.InitWithShallowSlice(host_u_adm, adm::ADM::I_ADM_PSI4);
  host_adm.g_dd.InitWithShallowSlice(host_u_adm, adm::ADM::I_ADM_GXX, adm::ADM::I_ADM_GZZ);
  host_adm.vK_dd.InitWithShallowSlice(host_u_adm, adm::ADM::I_ADM_KXX, adm::ADM::I_ADM_KZZ);

  auto &indcs = pmbp->pmesh->mb_indcs;
  auto &size = pmbp->pmb->mb_size;
  int &is = indcs.is; int &ie = indcs.ie;
  int &js = indcs.js; int &je = indcs.je;
  int &ks = indcs.ks; int &ke = indcs.ke;
  // For GLOOPS
  int isg = is-indcs.ng; int ieg = ie+indcs.ng;
  int jsg = js-indcs.ng; int jeg = je+indcs.ng;
  int ksg = ks-indcs.ng; int keg = ke+indcs.ng;
  int nmb = pmbp->nmb_thispack;


    // Now scatter into host_adm
  for (int m = 0; m < nmb; ++m) {
    for (int kk = isg; kk <= ieg; ++kk) {
    for (int jj = jsg; jj <= jeg; ++jj) {
    for (int ii = ksg; ii <= ieg; ++ii) {
      Real &x1min = size.d_view(m).x1min;
      Real &x1max = size.d_view(m).x1max;
      int nx1 = indcs.nx1;
      Real xx = CellCenterX(ii-is, nx1, x1min, x1max);
  
      Real &x2min = size.d_view(m).x2min;
      Real &x2max = size.d_view(m).x2max;
      int nx2 = indcs.nx2;
      Real yy = CellCenterX(jj-js, nx2, x2min, x2max);
  
      Real &x3min = size.d_view(m).x3min;
      Real &x3max = size.d_view(m).x3max;
      int nx3 = indcs.nx3;
      Real zz = CellCenterX(kk-ks, nx3, x3min, x3max);

      // — find which HDF5 meshblock contains (xx,yy,zz)
      int meshblock = 0;
      for (int l = 0; l < number_of_meshblocks; ++l) {
        double dx = data_x1v[l*meshblock_dimx + 1] - data_x1v[l*meshblock_dimx + 0];
        double dy = data_x2v[l*meshblock_dimy + 1] - data_x2v[l*meshblock_dimy + 0];
        double dz = data_x3v[l*meshblock_dimz + 1] - data_x3v[l*meshblock_dimz + 0];
        double xmin = data_x1v[l*meshblock_dimx + 0] - dx/2;
        double xmax = data_x1v[(l+1)*meshblock_dimx - 1] + dx/2;
        double ymin = data_x2v[l*meshblock_dimy + 0] - dy/2;
        double ymax = data_x2v[(l+1)*meshblock_dimy - 1] + dy/2;
        double zmin = data_x3v[l*meshblock_dimz + 0] - dz/2;
        double zmax = data_x3v[(l+1)*meshblock_dimz - 1] + dz/2;
        if (xx>xmin && xx<=xmax && yy>ymin && yy<=ymax && zz>zmin && zz<=zmax) {
          meshblock = l;
          break;
        }
      }

      // — find nearest indices within that block
      int sx = meshblock*meshblock_dimx, ex = (meshblock+1)*meshblock_dimx;
      int sy = meshblock*meshblock_dimy, ey = (meshblock+1)*meshblock_dimy;
      int sz = meshblock*meshblock_dimz, ez = (meshblock+1)*meshblock_dimz;
      int rel_ix = find_closest_index(data_x1v, sx, ex, xx);
      int rel_iy = find_closest_index(data_x2v, sy, ey, yy);
      int rel_iz = find_closest_index(data_x3v, sz, ez, zz);

      // — linear offset into the 5‑D arrays
      int local_idx = meshblock*block_vol
                    + rel_ix + NX*(rel_iy + NY*rel_iz);

      // — scatter metric (6 comps: gxx,gxy,gxz,gyy,gyz,gzz)
      host_adm.g_dd(m,0,0,kk,jj,ii) = metric_data[0*comp_stride + local_idx];
      host_adm.g_dd(m,0,1,kk,jj,ii) = metric_data[1*comp_stride + local_idx];
      host_adm.g_dd(m,0,2,kk,jj,ii) = metric_data[2*comp_stride + local_idx];
      host_adm.g_dd(m,1,1,kk,jj,ii) = metric_data[3*comp_stride + local_idx];
      host_adm.g_dd(m,1,2,kk,jj,ii) = metric_data[4*comp_stride + local_idx];
      host_adm.g_dd(m,2,2,kk,jj,ii) = metric_data[5*comp_stride + local_idx];

      // — scatter extrinsic K (6 comps: Kxx,Kxy,Kxz,Kyy,Kyz,Kzz)
      host_adm.vK_dd(m,0,0,kk,jj,ii) = extrin_data[0*comp_stride + local_idx];
      host_adm.vK_dd(m,0,1,kk,jj,ii) = extrin_data[1*comp_stride + local_idx];
      host_adm.vK_dd(m,0,2,kk,jj,ii) = extrin_data[2*comp_stride + local_idx];
      host_adm.vK_dd(m,1,1,kk,jj,ii) = extrin_data[3*comp_stride + local_idx];
      host_adm.vK_dd(m,1,2,kk,jj,ii) = extrin_data[4*comp_stride + local_idx];
      host_adm.vK_dd(m,2,2,kk,jj,ii) = extrin_data[5*comp_stride + local_idx];
    }}} // end ii,jj,kk
  }    // end pack‐loop m

  // 5) Free buffers and copy to device
  std::free(data_x1v);
  std::free(data_x2v);
  std::free(data_x3v);
  std::free(metric_data);
  std::free(extrin_data);
  Kokkos::deep_copy(u_adm, host_u_adm);
}


void RefinementCondition(MeshBlockPack *pmbp) {
    pmbp->pz4c->pamr->Refine(pmbp);
}
