//======================================================================================== 
// AthenaK: astrophysical fluid dynamics & numerical relativity code 
// Copyright(C) 2020 James M. Stone <jmstone@ias.edu> and the Athena code team 
// Licensed under the 3-clause BSD License 
//======================================================================================== 
//! \file z4c_id_solve.cpp 
//  \brief Problem generator for loading in initial data generated by 
//  id_solve 

#include <algorithm> // For std::lower_bound 
#include <array> 
#include <cmath> 
#include <cstdlib> 
#include <iostream> 
#include <iterator>  // For std::distance 
#include <sstream> 
#include <stdexcept> // For std::runtime_error 
#include <string> 
#include <vector> 
#include <Kokkos_Timer.hpp> 

#include "athena.hpp" 
#include "coordinates/cell_locations.hpp" 
#include "coordinates/adm.hpp" 
#include "globals.hpp" 
#include "mesh/mesh.hpp" 
#include "parameter_input.hpp" 
#include "z4c/z4c.hpp" 
#include "z4c/z4c_amr.hpp" 

#include <hdf5.h> 

// Forward declarations for interpolator 
static double lagrange1D(const double *x, const double *f, double xp); 
static double interpolate_3d_cmajor( 
    const double *x, int nx, 
    const double *y, int ny, 
    const double *z, int nz, 
    const double *f, 
    double xp, double yp, double zp 
); 

//----------------------------------------------------------------------------- 
// Read a full dataset of doubles from an HDF5 file. 
void read_hdf5(const char *filename, double **data, hsize_t *dims, const char *DATASET_NAME) { 
    hid_t  file_id, dataset_id, dataspace_id; 
    herr_t status; 

    // Open the HDF5 file 
    file_id = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT); 
    if (file_id < 0) { 
        throw std::runtime_error("Error opening file: " + std::string(filename)); 
    } 

    // Open the dataset 
    dataset_id = H5Dopen2(file_id, DATASET_NAME, H5P_DEFAULT); 
    if (dataset_id < 0) { 
        H5Fclose(file_id); 
        throw std::runtime_error("Error opening dataset: " + std::string(DATASET_NAME)); 
    } 

    // Get dataspace and dimensions 
    dataspace_id = H5Dget_space(dataset_id); 
    H5Sget_simple_extent_dims(dataspace_id, dims, NULL); 

    // Compute total size 
    int rank = H5Sget_simple_extent_ndims(dataspace_id); 
    hsize_t total_size = 1; // Use hsize_t for safety 
    for (int d = 0; d < rank; ++d) total_size *= dims[d]; 

    // Allocate and read 
    try { 
        *data = new double[total_size]; 
    } catch (const std::bad_alloc& e) { 
        H5Sclose(dataspace_id); 
        H5Dclose(dataset_id); 
        H5Fclose(file_id); 
        throw std::runtime_error("Memory allocation failed for dataset " + std::string(DATASET_NAME)); 
    } 

    status = H5Dread(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, *data); 
    if (status < 0) { 
        delete[] *data; 
        *data = nullptr; 
        H5Sclose(dataspace_id); 
        H5Dclose(dataset_id); 
        H5Fclose(file_id); 
        throw std::runtime_error("Error reading dataset " + std::string(DATASET_NAME)); 
    } 

    // Cleanup 
    H5Sclose(dataspace_id); 
    H5Dclose(dataset_id); 
    H5Fclose(file_id); 
} 


// Forward declarations 
// (Modified signature to accept pin)
void LoadIDSolveData(MeshBlockPack *pmbp, ParameterInput *pin, const std::string &file_name); 
void RefinementCondition(MeshBlockPack *pmbp); 

//---------------------------------------------------------------------------------------- 
//! \fn ProblemGenerator::UserProblem_() 
//! \brief Problem Generator for id_solve initial data 
void ProblemGenerator::UserProblem(ParameterInput *pin, const bool restart) { 
    user_ref_func = RefinementCondition; 
    if (restart) return; 

    MeshBlockPack *pmbp = pmy_mesh_->pmb_pack; 
    auto &indcs = pmy_mesh_->mb_indcs; 

    std::cout << pin->GetOrAddString("problem", "id_filename", "EMPTY") << std::endl; 

    std::cout << "Start Loading id_solve Initial Data" << std::endl; 
    try { 
        // (Pass pin to LoadIDSolveData)
        LoadIDSolveData( 
            pmbp, 
            pin, 
            pin->GetOrAddString("problem", "id_filename", "EMPTY")); 
    } catch (const std::exception& e) { 
        std::cerr << "### FATAL ERROR in ProblemGenerator ###" << std::endl; 
        std::cerr << e.what() << std::endl; 
        exit(EXIT_FAILURE); 
    } 

    // Set lapse from conformal factor 
    // pmbp->pz4c->GaugePreCollapsedLapse(pmbp, pin); 

    // Set Z4c variables from ADM variables 
    // This requires ghost zones to be filled, which LoadIDSolveData now does. 
    switch (indcs.ng) { 
      case 2: pmbp->pz4c->ADMToZ4c<2>(pmbp, pin); break; 
      case 3: pmbp->pz4c->ADMToZ4c<3>(pmbp, pin); break; 
      case 4: pmbp->pz4c->ADMToZ4c<4>(pmbp, pin); break; 
    } 
    pmbp->pz4c->Z4cToADM(pmbp); 
    pmbp->pz4c->GaugePreCollapsedLapse(pmbp, pin); 

    // Compute ADM constraints on initial slice 
    switch (indcs.ng) { 
      case 2: pmbp->pz4c->ADMConstraints<2>(pmbp); break; 
      case 3: pmbp->pz4c->ADMConstraints<3>(pmbp); break; 
      case 4: pmbp->pz4c->ADMConstraints<4>(pmbp); break; 
    } 

    std::cout << "Loading initial data complete." << std::endl; 
} 
//----------------------------------------------------------------------------- 
//! \brief Load id_solve initial data from HDF5 into AthenaK mesh 
// (Modified signature to accept pin)
void LoadIDSolveData(MeshBlockPack *pmbp, ParameterInput *pin, const std::string &file_name) { 
  // 1) Read coordinate arrays 
  double *data_x1v=nullptr, *data_x2v=nullptr, *data_x3v=nullptr; 
  hsize_t dims_x[2], dims_y[2], dims_z[2]; 
  read_hdf5(file_name.c_str(), &data_x1v, dims_x, "x1v"); 
  read_hdf5(file_name.c_str(), &data_x2v, dims_y, "x2v"); 
  read_hdf5(file_name.c_str(), &data_x3v, dims_z, "x3v"); 

  int number_of_meshblocks =    static_cast<int>(dims_x[0]); 
  int meshblock_dimx         =    static_cast<int>(dims_x[1]); 
  int meshblock_dimy         =    static_cast<int>(dims_y[1]); 
  int meshblock_dimz         =    static_cast<int>(dims_z[1]); 

  // 2) Read the metric (6 comps) and extrinsic (6 comps) datasets 
  double *metric_data=nullptr, *extrin_data=nullptr; 
  hsize_t dims_m[5], dims_e[5]; 
  read_hdf5(file_name.c_str(), &metric_data, dims_m, "metric"); 
  read_hdf5(file_name.c_str(), &extrin_data, dims_e, "extrin"); 

  // dims_m = {6, #blocks, NX, NY, NZ} 
  int ncomp         = static_cast<int>(dims_m[0]);  // should be 6 
  int nblocks       = static_cast<int>(dims_m[1]);  // should match number_of_meshblocks 
  int NX            = static_cast<int>(dims_m[2]); 
  int NY            = static_cast<int>(dims_m[3]); 
  int NZ            = static_cast<int>(dims_m[4]); 
  int block_vol     = NX*NY*NZ; 
  int comp_stride   = nblocks * block_vol;      // bytes between successive components 

  // 3) Prepare AthenaK ADM host views 
  auto &u_adm       = pmbp->padm->u_adm; 
  auto  host_u_adm = create_mirror(u_adm); 
  z4c::Z4c::ADMhost_vars host_adm; 
  host_adm.psi4.InitWithShallowSlice(host_u_adm, adm::ADM::I_ADM_PSI4); 
  host_adm.g_dd.InitWithShallowSlice(host_u_adm, adm::ADM::I_ADM_GXX, adm::ADM::I_ADM_GZZ); 
  host_adm.vK_dd.InitWithShallowSlice(host_u_adm, adm::ADM::I_ADM_KXX, adm::ADM::I_ADM_KZZ); 

  auto &indcs = pmbp->pmesh->mb_indcs; 
  // KOKKOS FIX: Get the size structure, which contains h_view 
  auto &size = pmbp->pmb->mb_size;   

  int &is = indcs.is; int &ie = indcs.ie; 
  int &js = indcs.js; int &je = indcs.je; 
  int &ks = indcs.ks; int &ke = indcs.ke; 
  // For GLOOPS 
  int isg = is-indcs.ng; int ieg = ie+indcs.ng; 
  int jsg = js-indcs.ng; int jeg = je+indcs.ng; 
  int ksg = ks-indcs.ng; int keg = ke+indcs.ng; 
  int nmb = pmbp->nmb_thispack; 

  // Read parameters for puncture filling
  // Default r_fill = 0.0 means no filling
  Real r_fill = pin->GetOrAddReal("z4c", "r_fill", 0.5); 
  const bool apply_puncture_fill = (r_fill > 0.0); 
  const Real r_fill_sq = SQR(r_fill); 

  Real c0_x = pin->GetOrAddReal("z4c", "co_0_x", 0.0); 
  Real c0_y = pin->GetOrAddReal("z4c", "co_0_y", 0.0); 
  Real c0_z = pin->GetOrAddReal("z4c", "co_0_z", 0.0); 
  // --- MODIFICATION --- Read puncture mass for BH 0
  Real M_0 = pin->GetOrAddReal("z4c", "M_fill_0", 0.5); 
  
  Real c1_x = pin->GetOrAddReal("z4c", "co_1_x", 0.0); 
  Real c1_y = pin->GetOrAddReal("z4c", "co_1_y", 0.0); 
  Real c1_z = pin->GetOrAddReal("z4c", "co_1_z", 0.0); 
  // --- MODIFICATION --- Read puncture mass for BH 1
  Real M_1 = pin->GetOrAddReal("z4c", "M_fill_1", 0.5); 
  
  if (apply_puncture_fill) { 
      std::cout << "Applying puncture fill with r_fill = " << r_fill << std::endl; 
      std::cout << "  BH 0 center: (" << c0_x << ", " << c0_y << ", " << c0_z << "), M_0 = " << M_0 << std::endl; 
      std::cout << "  BH 1 center: (" << c1_x << ", " << c1_y << ", " << c1_z << "), M_1 = " << M_1 << std::endl; 
  }

  // Cache for 1D coordinate arrays from the last used HDF5 meshblock 
  int last_meshblock = -1; 
  std::vector<double> xd(NX), yd(NY), zd(NZ); 
  // PERF_FIX: Cache for the HDF5 block bounds 
  double xmin_b, xmax_b, ymin_b, ymax_b, zmin_b, zmax_b; 

  //--- UNIFIED PASS: Interpolate from HDF5 to fill ALL zones (active + ghost) --- 
  for (int m = 0; m < nmb; ++m) { 
    // REFACTOR: Loop over ghost zones AND active zones in one pass 
    for (int kk = ksg; kk <= keg; ++kk) { 
    for (int jj = jsg; jj <= jeg; ++jj) { 
    for (int ii = isg; ii <= ieg; ++ii) { 
        
      //=========== KOKKOS FIX =========== 
      // Use the pre-existing host-side view 'size.h_view(m)' 
      Real xx = CellCenterX(ii-is, indcs.nx1, size.h_view(m).x1min, size.h_view(m).x1max); 
      Real yy = CellCenterX(jj-js, indcs.nx2, size.h_view(m).x2min, size.h_view(m).x2max); 
      Real zz = CellCenterX(kk-ks, indcs.nx3, size.h_view(m).x3min, size.h_view(m).x3max); 
      //================================== 

      // PERF_FIX: Check if point is outside the cached HDF5 block 
      if (last_meshblock == -1 || 
          xx <= xmin_b || xx > xmax_b || 
          yy <= ymin_b || yy > ymax_b || 
          zz <= zmin_b || zz > zmax_b) { 

        // Find which HDF5 block contains this cell 
        int meshblock = -1; 
        
        // Assume source HDF5 has same ghost depth as current mesh
        int ng_src = indcs.ng; 

        // Two-pass search: 
        // Pass 0: Prefer block where point is in Active region (avoids ghost/biased stencil)
        // Pass 1: Fallback to block where point is in Ghost region (for boundary points)
        for (int pass = 0; pass < 2; ++pass) {
            for (int l = 0; l < number_of_meshblocks; ++l) { 
                // Assuming uniform grid *within* a block 
                double dx = data_x1v[l*meshblock_dimx + 1] - data_x1v[l*meshblock_dimx + 0]; 
                double dy = data_x2v[l*meshblock_dimy + 1] - data_x2v[l*meshblock_dimy + 0]; 
                double dz = data_x3v[l*meshblock_dimz + 1] - data_x3v[l*meshblock_dimz + 0]; 
                
                // Full extents (including ghosts)
                double xmin_l = data_x1v[l*meshblock_dimx+0]-dx/2.0; 
                double xmax_l = data_x1v[l*meshblock_dimx + meshblock_dimx-1]+dx/2.0; 
                double ymin_l = data_x2v[l*meshblock_dimy+0]-dy/2.0; 
                double ymax_l = data_x2v[l*meshblock_dimy + meshblock_dimy-1]+dy/2.0; 
                double zmin_l = data_x3v[l*meshblock_dimz+0]-dz/2.0; 
                double zmax_l = data_x3v[l*meshblock_dimz + meshblock_dimz-1]+dz/2.0; 

                // Determine search bounds for this pass
                double s_xmin = xmin_l, s_xmax = xmax_l;
                double s_ymin = ymin_l, s_ymax = ymax_l;
                double s_zmin = zmin_l, s_zmax = zmax_l;

                if (pass == 0) {
                    // Shrink bounds to Active region only
                    s_xmin += ng_src * dx; s_xmax -= ng_src * dx;
                    s_ymin += ng_src * dy; s_ymax -= ng_src * dy;
                    s_zmin += ng_src * dz; s_zmax -= ng_src * dz;
                }

                if (xx > s_xmin && xx <= s_xmax && 
                    yy > s_ymin && yy <= s_ymax && 
                    zz > s_zmin && zz <= s_zmax) { 
                    
                    meshblock = l; 
                    // Always cache the FULL bounds of the block we found 
                    xmin_b = xmin_l; xmax_b = xmax_l; 
                    ymin_b = ymin_l; ymax_b = ymax_l; 
                    zmin_b = zmin_l; zmax_b = zmax_l; 
                    break; 
                } 
            }
            // If we found a valid block in Pass 0, do not run Pass 1
            if (meshblock != -1) break;
        }

        if (meshblock == -1) { 
            // Point is not in any block (e.g., ghost cell outside HDF5 domain) 
            if (m==0 && (ii<is || ii>ie || jj<js || jj>je || kk<ks || kk>ke)) { 
              // Warn once, only for a ghost cell 
              static bool warned = false; 
              if (!warned) { 
                std::cerr << "WARNING: Ghost point (" << xx << "," << yy << "," << zz 
                          << ") not found in HDF5 domain. Data may be uninitialized." << std::endl; 
                warned = true; 
              } 
            } else { 
              // Active cell not found: this is a fatal error 
              std::stringstream msg; 
              msg << "Active cell (" << xx << "," << yy << "," << zz << ") not found in HDF5 domain."; 
              throw std::runtime_error(msg.str()); 
            } 
            last_meshblock = -1; // Invalidate cache 
            continue; // Skip interpolation 
        } 

        if (meshblock != last_meshblock) { 
          for (int i=0; i<NX; ++i) xd[i] = data_x1v[meshblock*meshblock_dimx + i]; 
          for (int j=0; j<NY; ++j) yd[j] = data_x2v[meshblock*meshblock_dimy + j]; 
          for (int k=0; k<NZ; ++k) zd[k] = data_x3v[meshblock*meshblock_dimz + k]; 
          last_meshblock = meshblock; 
        } 
      } 
        
      // If last_meshblock is -1, we skipped, so check again 
      if (last_meshblock == -1) continue; 

      const double *xd_ptr=xd.data(), *yd_ptr=yd.data(), *zd_ptr=zd.data(); 
      const double *metric_ptr = metric_data + (last_meshblock * block_vol); 
      const double *extrin_ptr = extrin_data + (last_meshblock * block_vol); 

      host_adm.g_dd(m,0,0,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, metric_ptr + 0*comp_stride, xx,yy,zz); 
      host_adm.g_dd(m,0,1,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, metric_ptr + 1*comp_stride, xx,yy,zz); 
      host_adm.g_dd(m,0,2,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, metric_ptr + 2*comp_stride, xx,yy,zz); 
      host_adm.g_dd(m,1,1,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, metric_ptr + 3*comp_stride, xx,yy,zz); 
      host_adm.g_dd(m,1,2,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, metric_ptr + 4*comp_stride, xx,yy,zz); 
      host_adm.g_dd(m,2,2,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, metric_ptr + 5*comp_stride, xx,yy,zz); 
      host_adm.vK_dd(m,0,0,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, extrin_ptr + 0*comp_stride, xx,yy,zz); 
      host_adm.vK_dd(m,0,1,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, extrin_ptr + 1*comp_stride, xx,yy,zz); 
      host_adm.vK_dd(m,0,2,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, extrin_ptr + 2*comp_stride, xx,yy,zz); 
      host_adm.vK_dd(m,1,1,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, extrin_ptr + 3*comp_stride, xx,yy,zz); 
      host_adm.vK_dd(m,1,2,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, extrin_ptr + 4*comp_stride, xx,yy,zz); 
      host_adm.vK_dd(m,2,2,kk,jj,ii) = interpolate_3d_cmajor(xd_ptr,NX,yd_ptr,NY,zd_ptr,NZ, extrin_ptr + 5*comp_stride, xx,yy,zz); 
   
      // Apply puncture fill modification
      if (apply_puncture_fill) {
          // Add a small epsilon to avoid division by zero at the exact center
          const Real eps = 1.0e-12; 
          
          Real r0 = std::sqrt(SQR(xx - c0_x) + SQR(yy - c0_y) + SQR(zz - c0_z)) + eps;
          Real r1 = std::sqrt(SQR(xx - c1_x) + SQR(yy - c1_y) + SQR(zz - c1_z)) + eps;
          Real r = std::min(r0, r1); // Use radius to *closest* puncture

          if (r < r_fill) {
              // We are inside the fill-radius of at least one puncture.
              // Calculate the smoothstep transition function f(r)
              // f(r) goes from 1 (at r=0) to 0 (at r=r_fill)
              Real x = r / r_fill;
              // C^2 smoothstep function f(x) = 1 - 10x^3 + 15x^4 - 6x^5
              Real f = 1.0 - x*x*x * (10.0 - 15.0*x + 6.0*x*x); 
              if (x >= 1.0) f = 0.0; // clamp for r >= r_fill
              // if (x <= 0.0) f = 1.0; // clamp for r <= 0 (covered by eps)

              // Calculate the pure puncture conformal factor psi
              // This assumes a simple non-spinning Bowen-York puncture
              // psi = 1 + M_0/(2r_0) + M_1/(2r_1)
              Real psi_punc = 1.0 + M_0 / (2.0 * r0);
              psi_punc += M_1 / (2.0 * r1);

              Real psi4_punc = SQR(SQR(psi_punc));

              // Get the interpolated values (g_interp, K_interp)
              Real g_xx_interp = host_adm.g_dd(m,0,0,kk,jj,ii);
              Real g_yy_interp = host_adm.g_dd(m,1,1,kk,jj,ii);
              Real g_zz_interp = host_adm.g_dd(m,2,2,kk,jj,ii);

              // The "puncture" solution is g_punc = psi^4 * delta_ij, K_punc = 0
              // Blend: var = f * var_punc + (1-f) * var_interp

              // Blend metric
              // g_xx = f * (psi4_punc) + (1-f) * g_xx_interp
              host_adm.g_dd(m,0,0,kk,jj,ii) = f * psi4_punc + (1.0 - f) * g_xx_interp;
              // g_xy = f * (0.0) + (1-f) * g_xy_interp
              host_adm.g_dd(m,0,1,kk,jj,ii) *= (1.0 - f);
              // g_xz = f * (0.0) + (1-f) * g_xz_interp
              host_adm.g_dd(m,0,2,kk,jj,ii) *= (1.0 - f);
              // g_yy = f * (psi4_punc) + (1-f) * g_yy_interp
              host_adm.g_dd(m,1,1,kk,jj,ii) = f * psi4_punc + (1.0 - f) * g_yy_interp;
              // g_yz = f * (0.0) + (1-f) * g_yz_interp
              host_adm.g_dd(m,1,2,kk,jj,ii) *= (1.0 - f);
              // g_zz = f * (psi4_punc) + (1-f) * g_zz_interp
              host_adm.g_dd(m,2,2,kk,jj,ii) = f * psi4_punc + (1.0 - f) * g_zz_interp;

              // Blend extrinsic curvature (K_punc = 0)
              // K_ij = f * (0.0) + (1-f) * K_ij_interp
              host_adm.vK_dd(m,0,0,kk,jj,ii) *= (1.0 - f);
              host_adm.vK_dd(m,0,1,kk,jj,ii) *= (1.0 - f);
              host_adm.vK_dd(m,0,2,kk,jj,ii) *= (1.0 - f);
              host_adm.vK_dd(m,1,1,kk,jj,ii) *= (1.0 - f);
              host_adm.vK_dd(m,1,2,kk,jj,ii) *= (1.0 - f);
              host_adm.vK_dd(m,2,2,kk,jj,ii) *= (1.0 - f);
          }
          // else (r >= r_fill), do nothing. The interpolated values are kept.
      }
    }}} 
  } 

  // 5) Free buffers and copy to device 
  delete[] data_x1v; 
  delete[] data_x2v; 
  delete[] data_x3v; 
  delete[] metric_data; 
  delete[] extrin_data; 
  Kokkos::deep_copy(u_adm, host_u_adm); 
} 


void RefinementCondition(MeshBlockPack *pmbp) { 
    pmbp->pz4c->pamr->Refine(pmbp); 
} 

//---------------------------------------------------------------------------------------- 
// Helper functions for 4th-order interpolation 
//---------------------------------------------------------------------------------------- 

//! \fn lagrange1D 
//! \brief 1D Lagrange interpolation over a 5-point stencil. 
static double lagrange1D(const double *x, const double *f, double xp) { 
    double result = 0.0; 
    for (int i = 0; i < 5; i++) { 
        double term = f[i]; 
        for (int j = 0; j < 5; j++) { 
            if (j != i) { 
                term *= (xp - x[j]) / (x[i] - x[j]); 
            } 
        } 
        result += term; 
    } 
    return result; 
} 

//! \fn interpolate_3d_cmajor 
//! \brief 4th-order accurate 3D interpolation using a 5-point stencil 
//!        for data in C-major ([z][y][x]) layout. 
static double interpolate_3d_cmajor( 
    const double *x, int nx, 
    const double *y, int ny, 
    const double *z, int nz, 
    const double *f, 
    double xp, double yp, double zp 
) { 
    // Clamp coordinates to nearest domain edge (nearest-neighbor extrapolation) 
    if (xp < x[0]) xp = x[0]; 
    else if (xp > x[nx-1]) xp = x[nx-1]; 

    if (yp < y[0]) yp = y[0]; 
    else if (yp > y[ny-1]) yp = y[ny-1]; 

    if (zp < z[0]) zp = z[0]; 
    else if (zp > z[nz-1]) zp = z[nz-1]; 

    // PERF_FIX: Use binary search (O(log N)) instead of linear search (O(N)) 
    auto find_closest_index = [](const double *arr, int n, double val) { 
        const double *it = std::lower_bound(arr, arr + n, val); 
        int idx = std::distance(arr, it); 
        if (idx == n) { 
            idx = n - 1; 
        } else if (idx > 0) { 
            if (std::fabs(val - arr[idx - 1]) < std::fabs(val - arr[idx])) { 
                idx = idx - 1; 
            } 
        } 
        return idx; 
    }; 

    int ix = find_closest_index(x, nx, xp); 
    int iy = find_closest_index(y, ny, yp); 
    int iz = find_closest_index(z, nz, zp); 

    // Define 5-point stencil, clamping to array bounds 
    int sx = ix - 2; if (sx < 0) sx = 0; if (sx > nx - 5) sx = nx - 5; 
    int sy = iy - 2; if (sy < 0) sy = 0; if (sy > ny - 5) sy = ny - 5; 
    int sz = iz - 2; if (sz < 0) sz = 0; if (sz > nz - 5) sz = nz - 5; 

    double x5[5], y5[5], z5[5]; 
    for (int i = 0; i < 5; i++) { 
        x5[i] = x[sx + i]; 
        y5[i] = y[sy + i]; 
        z5[i] = z[sz + i]; 
    } 

    // Interpolation along z-axis 
    double yz_interp[5][5]; 
    for (int i = 0; i < 5; i++) { // x-stencil index 
        for (int j = 0; j < 5; j++) { // y-stencil index 
            double fz[5]; 
            for (int k = 0; k < 5; k++) { // z-stencil index 
                int idx = (sz + k) * ny * nx + (sy + j) * nx + (sx + i); 
                fz[k] = f[idx]; 
            } 
            yz_interp[i][j] = lagrange1D(z5, fz, zp); 
        } 
    } 

    // Interpolation along y-axis 
    double x_interp[5]; 
    for (int i = 0; i < 5; i++) { 
        double fy[5]; 
        for (int j = 0; j < 5; j++) { 
            fy[j] = yz_interp[i][j]; 
        } 
        x_interp[i] = lagrange1D(y5, fy, yp); 
    } 

    // Final interpolation along x-axis 
    return lagrange1D(x5, x_interp, xp); 
}