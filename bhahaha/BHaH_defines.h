#ifndef __BHAH_DEFINES_H__
#define __BHAH_DEFINES_H__
// BHaH core header file, automatically generated from output_BHaH_defines_h within BHaH_defines_h.py,
//    DO NOT EDIT THIS FILE BY HAND.

// ----------------------------
// Basic definitions for module
// general:
// ----------------------------
#include <ctype.h>   // Character type functions, such as isdigit, isalpha, etc.
#include <errno.h>   // Error number definitions
#include <math.h>    // Transcendental functions, etc.
#include <stdbool.h> // bool-typed variables
#include <stdint.h>  // int8_t-typed variables
#include <stdio.h>   // Basic input/output functions, such as *printf, fopen, fwrite, etc.
#include <stdlib.h>  // malloc/free, etc.
#include <string.h>  // String handling functions, such as strlen, strcmp, etc.
#include <time.h>    // Time-related functions and types, such as time(), clock(),
#define REAL double
#define DOUBLE double

// These macros for MIN(), MAX(), and SQR() ensure that if the arguments inside
//   are a function/complex expression, the function/expression is evaluated
//   *only once* per argument. See https://lwn.net/Articles/983965/ for details.
// They are improvements over the original implementations:
// #define MIN(A, B) ( ((A) < (B)) ? (A) : (B) )
// #define MAX(A, B) ( ((A) > (B)) ? (A) : (B) )
// #define SQR(A) ((A) * (A))
#define MIN(A, B)                                                                                                                                    \
  ({                                                                                                                                                 \
    __typeof__(A) _a = (A);                                                                                                                          \
    __typeof__(B) _b = (B);                                                                                                                          \
    _a < _b ? _a : _b;                                                                                                                               \
  })
#define MAX(A, B)                                                                                                                                    \
  ({                                                                                                                                                 \
    __typeof__(A) _a = (A);                                                                                                                          \
    __typeof__(B) _b = (B);                                                                                                                          \
    _a > _b ? _a : _b;                                                                                                                               \
  })
#define SQR(A)                                                                                                                                       \
  ({                                                                                                                                                 \
    __typeof__(A) _a = (A);                                                                                                                          \
    _a *_a;                                                                                                                                          \
  })
#ifndef MAYBE_UNUSED
#if __cplusplus >= 201703L
#define MAYBE_UNUSED [[maybe_unused]]
#elif defined(__GNUC__) || defined(__clang__) || defined(__NVCC__)
#define MAYBE_UNUSED __attribute__((unused))
#else
#define MAYBE_UNUSED
#endif // END check for GCC, Clang, or NVCC
#endif // END MAYBE_UNUSED
// START: CodeParameters declared as #define.
#ifndef MAXNUMGRIDS
#define MAXNUMGRIDS 15 // nrpy.grid
#endif
// END: CodeParameters declared as #define.

// ----------------------------
// Basic definitions for module
// after_general:
// ----------------------------
#include "BHaHAHA.h"

// ----------------------------
// Basic definitions for module
// commondata_struct:
// ----------------------------
typedef struct __commondata_struct__ {
  REAL *restrict coarse_horizon; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: most recently found coarse-resolution horizon h(theta,
                                 // phi) on the evolution grid
  REAL *restrict coarse_horizon_r_theta_phi[3]; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: coarse horizon r_theta_phi
  REAL *restrict external_input_gfs; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up: 14 gridfunctions provided by external
                                     // source, including gamma_ij and K_ij, in spherical rescaled basis, with ghostzones.
  REAL *restrict external_input_gfs_Cart_basis_no_gzs; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up: 14 gridfunctions
                                                       // provided by external source, including gamma_ij and K_ij, in Cartesian basis, with no
                                                       // ghostzones.
  REAL *restrict external_input_r_theta_phi[3];        // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up: Three 1D arrays storing
                                                       // uniform (r, theta, phi) coordinates.
  REAL *restrict h_p; // <- nrpy.infrastructures.BHaH.BHaHAHA.over_relaxation: Previously stored horizon guess, used for linear extrapolated
                      // over-relaxation.
  REAL *restrict interp_src_gfs; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up: 35 3D volume-filling gridfunctions with same
                                 // angular sampling as evolved grid, but same radial sampling as input_gfs. GFs include: h_ij, h_ij,k, a_ij, trK, W,
                                 // and W_,k. In RESCALED SPHERICAL basis.
  REAL *restrict interp_src_r_theta_phi[3]; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up: Source grid coordinates
  REAL CFL_FACTOR;                          // (nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all)
  REAL KO_diss_strength;                    // (nrpy.infrastructures.BHaH.BHaHAHA.rhs_eval_KO_apply)
  REAL bcstruct_Nxx_plus_2NGHOSTS0; // <- nrpy.infrastructures.BHaH.BHaHAHA.bcstruct_set_up: The Nxx_plus_2NGHOSTS0 used when setting up bcstruct
  REAL bcstruct_Nxx_plus_2NGHOSTS1; // <- nrpy.infrastructures.BHaH.BHaHAHA.bcstruct_set_up: The Nxx_plus_2NGHOSTS1 used when setting up bcstruct
  REAL bcstruct_Nxx_plus_2NGHOSTS2; // <- nrpy.infrastructures.BHaH.BHaHAHA.bcstruct_set_up: The Nxx_plus_2NGHOSTS2 used when setting up bcstruct
  REAL bcstruct_dxx0;               // <- nrpy.infrastructures.BHaH.BHaHAHA.bcstruct_set_up: The dxx0 used when setting up bcstruct
  REAL bcstruct_dxx1;               // <- nrpy.infrastructures.BHaH.BHaHAHA.bcstruct_set_up: The dxx1 used when setting up bcstruct
  REAL bcstruct_dxx2;               // <- nrpy.infrastructures.BHaH.BHaHAHA.bcstruct_set_up: The dxx2 used when setting up bcstruct
  REAL coarse_horizon_dxx1;         // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: coarse horizon dxx1
  REAL coarse_horizon_dxx2;         // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: coarse horizon dxx2
  REAL dt;                          // (nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all)
  REAL eta_damping;                 // (nrpy.infrastructures.BHaH.BHaHAHA.rhs_eval_KO_apply)
  REAL external_input_dxx0;         // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  REAL external_input_dxx1;         // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  REAL external_input_dxx2;         // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  REAL external_input_invdxx0;      // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  REAL external_input_invdxx1;      // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  REAL external_input_invdxx2;      // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  REAL interp_src_dxx0;             // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  REAL interp_src_dxx1;             // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  REAL interp_src_dxx2;             // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  REAL interp_src_invdxx0;          // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  REAL interp_src_invdxx1;          // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  REAL interp_src_invdxx2;          // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  REAL max_radius_wrt_grid_center;  // (nrpy.infrastructures.BHaH.BHaHAHA.diagnostics_area_centroid_and_Theta_norms)
  REAL min_radius_wrt_grid_center;  // (nrpy.infrastructures.BHaH.BHaHAHA.diagnostics_area_centroid_and_Theta_norms)
  REAL t_0;                         // (nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all)
  REAL t_final;                     // (nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all)
  REAL time;                        // (nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all)
  REAL time_of_h_p;                 // <- nrpy.infrastructures.BHaH.BHaHAHA.over_relaxation: Time at which previously stored horizon guess was stored.
  bhahaha_diagnostics_struct
      *restrict bhahaha_diagnostics; // <- nrpy.infrastructures.BHaH.BHaHAHA.diagnostics: diagnostics quantities; struct defined in BHaHAHA.h
  bhahaha_params_and_data_struct *restrict bhahaha_params_and_data; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: input parameters and
                                                                    // data set by the external code
  int NUMGRIDS;                                                     // (nrpy.grid)
  int coarse_horizon_Nxx_plus_2NGHOSTS1; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: coarse horizon Nxx_plus_2NGHOSTS1
  int coarse_horizon_Nxx_plus_2NGHOSTS2; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: coarse horizon Nxx_plus_2NGHOSTS2
  int error_flag;          // <- nrpy.infrastructures.BHaH.BHaHAHA.error_message: Enables subroutines to pass error flags to parent routines.
  int external_input_Nxx0; // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  int external_input_Nxx1; // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  int external_input_Nxx2; // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  int external_input_Nxx_plus_2NGHOSTS0; // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  int external_input_Nxx_plus_2NGHOSTS1; // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  int external_input_Nxx_plus_2NGHOSTS2; // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up)
  int interp_src_Nxx0;                   // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  int interp_src_Nxx1;                   // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  int interp_src_Nxx2;                   // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  int interp_src_Nxx_plus_2NGHOSTS0;     // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  int interp_src_Nxx_plus_2NGHOSTS1;     // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  int interp_src_Nxx_plus_2NGHOSTS2;     // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up)
  int is_final_iteration;                // <- nrpy.infrastructures.BHaH.BHaHAHA.diagnostics: diagnostics quantities; struct defined in BHaHAHA.h
  int nn;                                // (nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all)
  int nn_0;                              // (nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all)
  int output_diagnostics_every_nn;       // (nrpy.infrastructures.BHaH.BHaHAHA.diagnostics)
  int use_coarse_horizon; // <- nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up: prolongate h from coarse to finer, in initial_data(); 1=yes,
                          // 0=no
} commondata_struct;

// ----------------------------
// Basic definitions for module
// params_struct:
// ----------------------------
typedef struct __params_struct__ {
  REAL Cart_originx;         // (nrpy.grid)
  REAL Cart_originy;         // (nrpy.grid)
  REAL Cart_originz;         // (nrpy.grid)
  REAL PI;                   // (nrpy.reference_metric)
  REAL RMAX;                 // (nrpy.reference_metric)
  REAL dxx0;                 // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  REAL dxx1;                 // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  REAL dxx2;                 // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  REAL grid_hole_radius;     // (nrpy.reference_metric)
  REAL grid_physical_size;   // (nrpy.reference_metric)
  REAL invdxx0;              // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  REAL invdxx1;              // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  REAL invdxx2;              // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  bool grid_rotates;         // (nrpy.grid)
  char CoordSystemName[100]; // (nrpy.reference_metric)
  int Nxx0;                  // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  int Nxx1;                  // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  int Nxx2;                  // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  int Nxx_plus_2NGHOSTS0;    // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  int Nxx_plus_2NGHOSTS1;    // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
  int Nxx_plus_2NGHOSTS2;    // (nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up)
} params_struct;

// ----------------------------
// Basic definitions for module
// finite_difference:
// ----------------------------

// Set the number of ghost zones
// Note that upwinding in e.g., BSSN requires that NGHOSTS = fd_order/2 + 1 <- Notice the +1.
#define NGHOSTS 3

// Declare NO_INLINE macro, used in FD functions. GCC v10+ compilations hang on complex RHS expressions (like BSSN) without this.
#if defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER)
#define NO_INLINE __attribute__((noinline))
#elif defined(_MSC_VER)
#define NO_INLINE __declspec(noinline)
#else
#define NO_INLINE // Fallback for unknown compilers
#endif

// ----------------------------
// Basic definitions for module
// reference_metric:
// ----------------------------
typedef struct __rfmstruct__ {
  REAL *restrict f0_of_xx0;
  REAL *restrict f1_of_xx1;
  REAL *restrict f1_of_xx1__D1;
  REAL *restrict f1_of_xx1__DD11;
} rfm_struct;

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.CurviBoundaryConditions.CurviBoundaryConditions:
// ----------------------------

// NRPy Curvilinear Boundary Conditions: Core data structures
typedef struct {
  int dstpt;         // dstpt is the 3D grid index IDX3(i0,i1,i2) of the inner boundary point (i0,i1,i2)
  int srcpt;         // srcpt is the 3D grid index (a la IDX3) to which the inner boundary point maps
  int8_t parity[28]; // parity[28] is a calculation of dot products for the 28 independent parity types
} innerpt_bc_struct;

typedef struct {
  short i0, i1, i2;              // the outer boundary point grid index (i0,i1,i2), on the 3D grid
  int8_t FACEX0, FACEX1, FACEX2; // 1-byte integers that store
  //                               FACEX0,FACEX1,FACEX2 = +1, 0, 0 if on the i0=i0min face,
  //                               FACEX0,FACEX1,FACEX2 = -1, 0, 0 if on the i0=i0max face,
  //                               FACEX0,FACEX1,FACEX2 =  0,+1, 0 if on the i1=i2min face,
  //                               FACEX0,FACEX1,FACEX2 =  0,-1, 0 if on the i1=i1max face,
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,+1 if on the i2=i2min face, or
  //                               FACEX0,FACEX1,FACEX2 =  0, 0,-1 if on the i2=i2max face,
} outerpt_bc_struct;

typedef struct {
  int num_inner_boundary_points;                  // stores total number of inner boundary points
  int num_pure_outer_boundary_points[NGHOSTS][3]; // stores number of outer boundary points on each
  //                                                  ghostzone level and direction (update min and
  //                                                  max faces simultaneously on multiple cores)
  int bc_loop_bounds[NGHOSTS][6][6]; // stores outer boundary loop bounds. Unused after bcstruct_set_up()
} bc_info_struct;

typedef struct {
  innerpt_bc_struct *restrict inner_bc_array;                   // information needed for updating each inner boundary point
  outerpt_bc_struct *restrict pure_outer_bc_array[NGHOSTS * 3]; // information needed for updating each outer
  //                                                                        boundary point
  bc_info_struct bc_info; // stores number of inner and outer boundary points, needed for setting loop
  //                                  bounds and parallelizing over as many boundary points as possible.
} bc_struct;

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all:
// ----------------------------
typedef struct __MoL_gridfunctions_struct__ {
  REAL *restrict y_n_gfs;
  REAL *restrict next_y_input_gfs;
  REAL *restrict k1_gfs;
  REAL *restrict k2_gfs;
  REAL *restrict k3_gfs;
  REAL *restrict auxevol_gfs;
  REAL *restrict diagnostic_output_gfs;
  REAL *restrict diagnostic_output_gfs2;
} MoL_gridfunctions_struct;

// ----------------------------
// Basic definitions for module
// grid:
// ----------------------------

// EVOL VARIABLES:
#define NUM_EVOL_GFS 2
#define HHGF 0
#define VVGF 1

// SET gridfunctions_f_infinity[i] = evolved gridfunction i's value in the limit r->infinity:
static const REAL gridfunctions_f_infinity[NUM_EVOL_GFS] = {0.0, 0.0};

// SET gridfunctions_wavespeed[i] = evolved gridfunction i's characteristic wave speed:
static const REAL gridfunctions_wavespeed[NUM_EVOL_GFS] = {1.0, 1.0};

// AUX VARIABLES:
#define NUM_AUX_GFS 1
#define THETAGF 0

// AUXEVOL VARIABLES:
#define NUM_AUXEVOL_GFS 35
#define ADD00GF 0
#define ADD01GF 1
#define ADD02GF 2
#define ADD11GF 3
#define ADD12GF 4
#define ADD22GF 5
#define HDD00GF 6
#define HDD01GF 7
#define HDD02GF 8
#define HDD11GF 9
#define HDD12GF 10
#define HDD22GF 11
#define PARTIAL_D_HDD000GF 12
#define PARTIAL_D_HDD001GF 13
#define PARTIAL_D_HDD002GF 14
#define PARTIAL_D_HDD011GF 15
#define PARTIAL_D_HDD012GF 16
#define PARTIAL_D_HDD022GF 17
#define PARTIAL_D_HDD100GF 18
#define PARTIAL_D_HDD101GF 19
#define PARTIAL_D_HDD102GF 20
#define PARTIAL_D_HDD111GF 21
#define PARTIAL_D_HDD112GF 22
#define PARTIAL_D_HDD122GF 23
#define PARTIAL_D_HDD200GF 24
#define PARTIAL_D_HDD201GF 25
#define PARTIAL_D_HDD202GF 26
#define PARTIAL_D_HDD211GF 27
#define PARTIAL_D_HDD212GF 28
#define PARTIAL_D_HDD222GF 29
#define PARTIAL_D_WW0GF 30
#define PARTIAL_D_WW1GF 31
#define PARTIAL_D_WW2GF 32
#define TRKGF 33
#define WWGF 34

// ----------------------------
// Indexing macros
// ----------------------------
// IDX4: Converts 4D grid indices (gf, i, j, k) into a 1D array index using the strides
//       Nxx_plus_2NGHOSTS0, Nxx_plus_2NGHOSTS1, and Nxx_plus_2NGHOSTS2. This macro assumes
//       that the "i" index varies fastest in memory.
#define IDX4(gf, i, j, k) ((i) + Nxx_plus_2NGHOSTS0 * ((j) + Nxx_plus_2NGHOSTS1 * ((k) + Nxx_plus_2NGHOSTS2 * (gf))))
// IDX4P: Similar to IDX4, but retrieves grid dimensions from the provided parameter structure
//        "params" instead of using global variables.
#define IDX4P(params, gf, i, j, k)                                                                                                                   \
  ((i) + (params)->Nxx_plus_2NGHOSTS0 * ((j) + (params)->Nxx_plus_2NGHOSTS1 * ((k) + (params)->Nxx_plus_2NGHOSTS2 * (gf))))
// IDX4pt: Computes the 1D index offset for a given grid function index (gf) based on an existing index (idx)
//         by using the total number of elements in one grid function, defined as the product of the grid strides.
#define IDX4pt(gf, idx) ((idx) + (Nxx_plus_2NGHOSTS0 * Nxx_plus_2NGHOSTS1 * Nxx_plus_2NGHOSTS2) * (gf))
// IDX4ptP: Similar to IDX4pt, but retrieves grid dimensions from the provided parameter structure
//        "params" instead of using global variables.
#define IDX4Ppt(params, gf, idx) ((idx) + ((params)->Nxx_plus_2NGHOSTS0 * (params)->Nxx_plus_2NGHOSTS1 * (params)->Nxx_plus_2NGHOSTS2) * (gf))
// IDX3: Converts 3D grid indices (i, j, k) into a 1D array index using the strides Nxx_plus_2NGHOSTS0
//       and Nxx_plus_2NGHOSTS1. Like IDX4, this macro assumes the "i" index varies fastest.
#define IDX3(i, j, k) ((i) + Nxx_plus_2NGHOSTS0 * ((j) + Nxx_plus_2NGHOSTS1 * ((k))))
// IDX3P: Similar to IDX3, but retrieves grid dimensions from the provided parameter structure "params".
#define IDX3P(params, i, j, k) ((i) + (params)->Nxx_plus_2NGHOSTS0 * ((j) + (params)->Nxx_plus_2NGHOSTS1 * ((k))))
// END: Indexing macros

// ----------------------------
// Loop-related macros
// ----------------------------
// SET_NXX_PLUS_2NGHOSTS_VARS: Declares local constants for the grid dimensions (including ghost zones) by extracting
// the values from griddata[whichgrid].params.
#define SET_NXX_PLUS_2NGHOSTS_VARS(whichgrid)                                                                                                        \
  const int Nxx_plus_2NGHOSTS0 = griddata[whichgrid].params.Nxx_plus_2NGHOSTS0;                                                                      \
  const int Nxx_plus_2NGHOSTS1 = griddata[whichgrid].params.Nxx_plus_2NGHOSTS1;                                                                      \
  const int Nxx_plus_2NGHOSTS2 = griddata[whichgrid].params.Nxx_plus_2NGHOSTS2;
// LOOP_REGION: Iterates over a 3D region defined by the inclusive lower bounds (i0min, i1min, i2min)
// and exclusive upper bounds (i0max, i1max, i2max) for each dimension.
#define LOOP_REGION(i0min, i0max, i1min, i1max, i2min, i2max)                                                                                        \
  for (int i2 = i2min; i2 < i2max; i2++)                                                                                                             \
    for (int i1 = i1min; i1 < i1max; i1++)                                                                                                           \
      for (int i0 = i0min; i0 < i0max; i0++)
// LOOP_OMP: Similar to LOOP_REGION but inserts an OpenMP pragma (via __OMP_PRAGMA__) for parallelization.
#define LOOP_OMP(__OMP_PRAGMA__, i0, i0min, i0max, i1, i1min, i1max, i2, i2min, i2max)                                                               \
  _Pragma(__OMP_PRAGMA__) for (int(i2) = (i2min); (i2) < (i2max); (i2)++) for (int(i1) = (i1min); (i1) < (i1max);                                    \
                                                                               (i1)++) for (int(i0) = (i0min); (i0) < (i0max); (i0)++)
// LOOP_NOOMP: A non-parallel version of the 3D loop, identical in structure to LOOP_REGION.
#define LOOP_NOOMP(i0, i0min, i0max, i1, i1min, i1max, i2, i2min, i2max)                                                                             \
  for (int(i2) = (i2min); (i2) < (i2max); (i2)++)                                                                                                    \
    for (int(i1) = (i1min); (i1) < (i1max); (i1)++)                                                                                                  \
      for (int(i0) = (i0min); (i0) < (i0max); (i0)++)
// LOOP_BREAKOUT: Forces an exit from the nested loops by setting the loop indices to their maximum values and executing a break.
#define LOOP_BREAKOUT(i0, i1, i2, i0max, i1max, i2max)                                                                                               \
  {                                                                                                                                                  \
    i0 = (i0max);                                                                                                                                    \
    i1 = (i1max);                                                                                                                                    \
    i2 = (i2max);                                                                                                                                    \
    break;                                                                                                                                           \
  }
// IS_IN_GRID_INTERIOR: Checks whether the provided 3D index array (i0i1i2) lies within the grid interior,
// defined as the region excluding NG ghost cells on each boundary.
#define IS_IN_GRID_INTERIOR(i0i1i2, Nxx_plus_2NGHOSTS0, Nxx_plus_2NGHOSTS1, Nxx_plus_2NGHOSTS2, NG)                                                  \
  (i0i1i2[0] >= (NG) && i0i1i2[0] < (Nxx_plus_2NGHOSTS0) - (NG) && i0i1i2[1] >= (NG) && i0i1i2[1] < (Nxx_plus_2NGHOSTS1) - (NG) &&                   \
   i0i1i2[2] >= (NG) && i0i1i2[2] < (Nxx_plus_2NGHOSTS2) - (NG))

// ----------------------------
// Define griddata struct
// ----------------------------
typedef struct __griddata__ {
  // griddata_struct stores data needed on each grid
  // xx[3] stores the uniform grid coordinates.
  REAL *restrict xx[3];
  // NRPy+ MODULE: nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up
  bc_struct bcstruct; // <- all data needed to apply boundary conditions in curvilinear coordinates
  // NRPy+ MODULE: nrpy.infrastructures.BHaH.MoLtimestepping.MoL_register_all
  MoL_gridfunctions_struct gridfuncs; // <- MoL gridfunctions
  // NRPy+ MODULE: params
  params_struct params; // <- BHaH parameters, generated from NRPy+'s CodeParameters
  // NRPy+ MODULE: reference_metric
  rfm_struct *rfmstruct; // <- includes e.g., 1D arrays of reference metric quantities
} griddata_struct;

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.BHaHAHA.interpolation_1d_radial_spokes_on_3d_src_grid:
// ----------------------------
#define NinterpGHOSTS (NGHOSTS - 1)

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.BHaHAHA.numgrid__evol_set_up:
// ----------------------------

/* PARITY TYPES FOR SRC GRID GRIDFUNCTIONS. */
static const int8_t evol_gf_parity[2] = {0, 0};

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.BHaHAHA.numgrid__external_input_set_up:
// ----------------------------

#define NUM_EXT_INPUT_CONFORMAL_GFS 14 // Number of external input grid functions
enum {
  EXTERNAL_SPHERICAL_ADD00GF,
  EXTERNAL_SPHERICAL_ADD01GF,
  EXTERNAL_SPHERICAL_ADD02GF,
  EXTERNAL_SPHERICAL_ADD11GF,
  EXTERNAL_SPHERICAL_ADD12GF,
  EXTERNAL_SPHERICAL_ADD22GF,
  EXTERNAL_SPHERICAL_HDD00GF,
  EXTERNAL_SPHERICAL_HDD01GF,
  EXTERNAL_SPHERICAL_HDD02GF,
  EXTERNAL_SPHERICAL_HDD11GF,
  EXTERNAL_SPHERICAL_HDD12GF,
  EXTERNAL_SPHERICAL_HDD22GF,
  EXTERNAL_SPHERICAL_TRKGF,
  EXTERNAL_SPHERICAL_WWGF,
};

/* PARITY TYPES FOR SRC GRID GRIDFUNCTIONS. */
static const int8_t external_input_gf_parity[14] = {4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9, 0, 0};

// ----------------------------
// Basic definitions for module
// nrpy.infrastructures.BHaH.BHaHAHA.numgrid__interp_src_set_up:
// ----------------------------

#define NUM_INTERP_SRC_GFS 35 // Number of interp_src grid functions
enum {
  SRC_ADD00GF,
  SRC_ADD01GF,
  SRC_ADD02GF,
  SRC_ADD11GF,
  SRC_ADD12GF,
  SRC_ADD22GF,
  SRC_HDD00GF,
  SRC_HDD01GF,
  SRC_HDD02GF,
  SRC_HDD11GF,
  SRC_HDD12GF,
  SRC_HDD22GF,
  SRC_PARTIAL_D_HDD000GF,
  SRC_PARTIAL_D_HDD001GF,
  SRC_PARTIAL_D_HDD002GF,
  SRC_PARTIAL_D_HDD011GF,
  SRC_PARTIAL_D_HDD012GF,
  SRC_PARTIAL_D_HDD022GF,
  SRC_PARTIAL_D_HDD100GF,
  SRC_PARTIAL_D_HDD101GF,
  SRC_PARTIAL_D_HDD102GF,
  SRC_PARTIAL_D_HDD111GF,
  SRC_PARTIAL_D_HDD112GF,
  SRC_PARTIAL_D_HDD122GF,
  SRC_PARTIAL_D_HDD200GF,
  SRC_PARTIAL_D_HDD201GF,
  SRC_PARTIAL_D_HDD202GF,
  SRC_PARTIAL_D_HDD211GF,
  SRC_PARTIAL_D_HDD212GF,
  SRC_PARTIAL_D_HDD222GF,
  SRC_PARTIAL_D_WW0GF,
  SRC_PARTIAL_D_WW1GF,
  SRC_PARTIAL_D_WW2GF,
  SRC_TRKGF,
  SRC_WWGF,
};

/* PARITY TYPES FOR SRC GRID GRIDFUNCTIONS. */
static const int8_t interp_src_gf_parity[35] = {4,  5,  6,  7,  8,  9,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,
                                                16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 1,  2,  3,  0,  0};

#ifndef BHAH_TYPEOF
#if __cplusplus >= 2000707L
#define BHAH_TYPEOF(a) decltype(a)
#elif defined(__GNUC__) || defined(__clang__) || defined(__NVCC__)
#define BHAH_TYPEOF(a) __typeof__(a)
#else
#define BHAH_TYPEOF(a)
#endif // END check for GCC, Clang, or C++
#endif // END BHAH_TYPEOF

#define BHAH_MALLOC(a, sz)                                                                                                                           \
  do {                                                                                                                                               \
    a = (BHAH_TYPEOF(a))malloc(sz);                                                                                                                  \
  } while (0);
#define BHAH_MALLOC__PtrMember(a, b, sz)                                                                                                             \
  do {                                                                                                                                               \
    if (a) {                                                                                                                                         \
      BHAH_MALLOC(a->b, sz);                                                                                                                         \
    }                                                                                                                                                \
  } while (0);

#define BHAH_FREE(a)                                                                                                                                 \
  do {                                                                                                                                               \
    if (a) {                                                                                                                                         \
      free((void *)(a));                                                                                                                             \
      (a) = NULL;                                                                                                                                    \
    }                                                                                                                                                \
  } while (0);
#define BHAH_FREE__PtrMember(a, b)                                                                                                                   \
  do {                                                                                                                                               \
    if (a) {                                                                                                                                         \
      BHAH_FREE(a->b);                                                                                                                               \
    }                                                                                                                                                \
  } while (0);
#endif